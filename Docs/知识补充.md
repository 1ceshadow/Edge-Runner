# 依赖注入（Dependency Injection, DI）
就像一个“全局服务注册表”或“容器”，允许你的脚本在运行时动态地注册（添加）和获取（查找）其他组件或服务，而不需要硬编码依赖。  

- 核心思想：你的脚本不直接创建或查找依赖对象，直接请求注册表  

解决的问题：旧代码中用FindGameObjectWithTag("Player")来查找玩家，这会导致：
- 紧耦合：脚本直接依赖具体GameObject。
- 性能开销：运行时查找慢。
- 测试难：单元测试时无法模拟依赖。

## 常见的四种DI方式

方式|代码写法示例|推荐指数
 --- |  --- | ---
Inspector 拖拽（最常见）|[SerializeField] private PlayerConfig config;|5 stars（入门）
Service Locator（你正在用）|var player = ServiceLocator.Get<IPlayerService>();|4 stars（推荐）
构造函数注入（最纯粹）|public Enemy(IPlayerService player) { this.player = player; }|5 stars（专业）
Zenject / VContainer（框架）|自动注入，无需手写|5 stars（终极）

大的项目一般用框架，小项目无所谓。但我觉得用框架也挺方便的

## 3个注入框架的比较
维度|ServiceLocator（你现在用的）|VContainer（推荐）|Zenject（社区老大哥）
--- | --- |                      --- |              ---
性能（每帧开销）|★★★★☆（几乎0分配）|★★★★★（真正0 GC，编译时生成）|★★★☆☆（有少量反射）
学习成本|★★★★★（最简单，5分钟上手）|★★★★☆（稍微陡一点）|★★★☆☆（概念多）
类型安全|★★☆☆☆（Get<T>() 运行时炸）|★★★★★（编译期全检查）|★★★★☆（大部分安全）
IDE支持（重构/跳转）|★★☆☆☆（全是object）|★★★★★（完美）|★★★★☆（好）
热重载（Editor Play）|★★★★★（几乎不报错）|★★★★☆（偶尔要重进）|★★★☆☆（经常炸）
适合你现在的项目规模|★★★★★（目前够用）|★★★★★（未来无痛升级）|★★★★☆（有点重）
替换难度（你现在的代码）|-|★★★★☆（3～5天可全量替换）|★★☆☆☆（至少2周）
与你现有EventBus的配合|完美（都是Runtime代码）|完美（甚至可以注入EventBus）|完美



## ScriptableObject 的 6 大真实身份
ScriptableObject = 可以保存成 .asset 文件的、纯数据类

名称|实际作用|对应的真实例子|为什么不用普通 C# 类或 JSON？
--- | --- |                                                  --- | --- 
GameConfig / PlayerConfig|全局平衡参数表|移动速度、闪现距离、时缓能量消耗、敌人血量等全在这里调|程序员/策划在 Inspector 里直接改，不用重新编译代码
LevelData / WaveData|关卡配置表|第 1 关刷 5 个 ShooterEnemy，第 10 秒刷 Boss|一键复制关卡、支持预制刷怪波、不用写死在代码里
ItemData / WeaponData|物品数据库|刀、枪、药水各自的图标、伤害、稀有度|几百把武器只要几百个 .asset 文件，超级清晰
DialogueData / StoryData|对话/剧情数据|过场动画说的话、选项分支|程序员写逻辑，策划填文本，完全解耦
AudioConfig / SoundBank|音效表|攻击音效、死亡音效、背景音乐全存在这里|换音效只需要换 asset，不动代码
LocalizationTable|多语言表|中文“开始游戏”、英文“Start Game”、日文“ゲーム開始”|支持热更新
